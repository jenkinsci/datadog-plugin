package org.datadog.jenkins.plugins.datadog.model;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.converters.UnmarshallingContext;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
import java.util.Collections;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import org.datadog.jenkins.plugins.datadog.traces.IdGenerator;
import org.datadog.jenkins.plugins.datadog.util.DatadogActionConverter;

/**
 * This action stores mapping between IDs of {@link org.jenkinsci.plugins.workflow.graph.FlowNode}
 * that are generated by Jenkins, and span IDs that are generated by the plugin.
 * <p>
 * Span ID is submitted with the rest of the tracing data when a pipeline step finishes,
 * but in certain cases it needs to be known before that:
 * <ul>
 *   <li>before an atomic step starts, we add its span ID to the step's environment so that the logic inside the step could create custom spans that are linked as children to the step's span</li>
 *   <li>if a stage step contains children, its children need to know their parent stage's span ID to use as their parent ID</li>
 * </ul>
 * For reasons above, we generate IDs for flow nodes on demand, and store them here
 * until execution of the corresponding nodes finishes.
 * Once the execution finishes, the IDs are no longer needed and can be removed.
 * It is important to remove IDs, because this action is regularly dumped to disk, so it should contain as little data as possible.
 * <p>
 * There is a single trace info action associated with the pipeline,
 * rather than a separate action with a single ID associated with the node.
 * This is done for performance reasons, as changes to run actions are batched,
 * while changes to node actions are written to disk immediately.
 */
public class TraceInfoAction extends DatadogPluginAction {

    private final ConcurrentMap<String, Long> spanIdByNodeId;

    public TraceInfoAction() {
        this(Collections.emptyMap());
    }

    public TraceInfoAction(Map<String, Long> spanIdByNodeId) {
        this.spanIdByNodeId = new ConcurrentHashMap<>(spanIdByNodeId);
    }

    public Long getOrCreate(String flowNodeId) {
        return spanIdByNodeId.computeIfAbsent(flowNodeId, k -> IdGenerator.generate());
    }

    public Long removeOrCreate(String flowNodeId) {
        Long existingId = spanIdByNodeId.remove(flowNodeId);
        if (existingId != null) {
            return existingId;
        } else {
            return IdGenerator.generate();
        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        TraceInfoAction that = (TraceInfoAction) o;
        return Objects.equals(spanIdByNodeId, that.spanIdByNodeId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(spanIdByNodeId);
    }

    @Override
    public String toString() {
        return "TraceInfoAction{" +
                "infoByFlowNodeId=" + spanIdByNodeId +
                '}';
    }

    public static final class ConverterImpl extends DatadogActionConverter {
        public ConverterImpl(XStream xs) {
        }

        @Override
        public boolean canConvert(Class type) {
            return TraceInfoAction.class == type;
        }

        @Override
        public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) {
            TraceInfoAction action = (TraceInfoAction) source;
            writeField("infoByFlowNodeId", action.spanIdByNodeId, writer, context);
        }

        @Override
        public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {
            Map<String, Long> infoByFlowNodeId = readField(reader, context, Map.class);
            return new TraceInfoAction(infoByFlowNodeId);
        }
    }
}
