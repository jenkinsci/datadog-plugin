package org.datadog.jenkins.plugins.datadog.model;

import static org.datadog.jenkins.plugins.datadog.util.conversion.VersionedConverter.*;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.converters.UnmarshallingContext;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
import java.util.Collections;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import org.datadog.jenkins.plugins.datadog.traces.IdGenerator;
import org.datadog.jenkins.plugins.datadog.util.conversion.DatadogConverter;
import org.datadog.jenkins.plugins.datadog.util.conversion.VersionedConverter;

/**
 * This action stores mapping between IDs of {@link org.jenkinsci.plugins.workflow.graph.FlowNode}
 * that are generated by Jenkins, and span IDs that are generated by the plugin.
 * <p>
 * Span ID is submitted with the rest of the tracing data when a pipeline step finishes,
 * but in certain cases it needs to be known before that:
 * <ul>
 *   <li>before an atomic step starts, we add its span ID to the step's environment so that the logic inside the step could create custom spans that are linked as children to the step's span</li>
 *   <li>if a stage step contains children, its children need to know their parent stage's span ID to use as their parent ID</li>
 * </ul>
 * For reasons above, we generate IDs for flow nodes on demand, and store them here
 * until execution of the corresponding nodes finishes.
 * Once the execution finishes, the IDs are no longer needed and can be removed.
 * It is important to remove IDs, because this action is regularly dumped to disk, so it should contain as little data as possible.
 * <p>
 * There is a single trace info action associated with the pipeline,
 * rather than a separate action with a single ID associated with the node.
 * This is done for performance reasons, as changes to run actions are batched,
 * while changes to node actions are written to disk immediately.
 */
public class TraceInfoAction extends DatadogPluginAction {

    private final ConcurrentMap<String, Long> spanIdByNodeId;

    public TraceInfoAction() {
        this(Collections.emptyMap());
    }

    public TraceInfoAction(Map<String, Long> spanIdByNodeId) {
        this.spanIdByNodeId = new ConcurrentHashMap<>(spanIdByNodeId);
    }

    public Long getOrCreate(String flowNodeId) {
        return spanIdByNodeId.computeIfAbsent(flowNodeId, k -> IdGenerator.generate());
    }

    public Long removeOrCreate(String flowNodeId) {
        Long existingId = spanIdByNodeId.remove(flowNodeId);
        if (existingId != null) {
            return existingId;
        } else {
            return IdGenerator.generate();
        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        TraceInfoAction that = (TraceInfoAction) o;
        return Objects.equals(spanIdByNodeId, that.spanIdByNodeId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(spanIdByNodeId);
    }

    @Override
    public String toString() {
        return "TraceInfoAction{" +
                "infoByFlowNodeId=" + spanIdByNodeId +
                '}';
    }

    public static final class ConverterImpl extends DatadogConverter<TraceInfoAction> {
        public ConverterImpl(XStream xs) {
            super(ignoreOldData(), new ConverterV1());
        }
    }

    public static final class ConverterV1 extends VersionedConverter<TraceInfoAction> {

        private static final int VERSION = 1;

        public ConverterV1() {
            super(VERSION);
        }

        @Override
        public void marshal(TraceInfoAction action, HierarchicalStreamWriter writer, MarshallingContext context) {
            writeField("infoByFlowNodeId", action.spanIdByNodeId, writer, context);
        }

        @Override
        public TraceInfoAction unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {
            Map<String, Long> infoByFlowNodeId = readField(reader, context, Map.class);
            return new TraceInfoAction(infoByFlowNodeId);
        }
    }
}
